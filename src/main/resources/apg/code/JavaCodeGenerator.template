/**
 * This code was auto-generated by apg.
 *
 * Changes to this file may cause incorrect behavior and will be lost if
 * the code is regenerated.
 */
package generated;

import java.io.IOException;
import java.io.InputStream;
import java.util.Stack;

public class Parser {
    private static final int END_MARKER = 256;
    private static final int MIN_RULE_ID = END_MARKER + 1;
    private CompressedMatrix<Integer> gotoTable;
    private CompressedMatrix<Action> actionTable;
    private Dfa[] reverseDfas;

    public Parser() {
        @@InitGotoTable
        @@InitActionTable
        @@InitReverseDfas
    }

    public boolean parse(InputStream stream) throws IOException {
        boolean isMatch = false;

        Stack<Integer> stateStack = new Stack<Integer>();
        Stack<Integer> inputStack = new Stack<Integer>();
        stateStack.push(0);

        int c = stream.read();
        if (c == -1) {
            c = END_MARKER;
        }

        while (true) {
            Action action = this.actionTable.get(stateStack.peek(), c);

            if (action == null) {
                isMatch = false;
                break;
            } else if (action.type() == ActionType.Shift) {
                stateStack.push(action.state());
                inputStack.push(c);

                c = stream.read();
                if (c == -1) {
                    c = END_MARKER;
                }
            } else if (action.type() == ActionType.Reduce) {
                Dfa fa = this.reverseDfas[action.ruleId() - MIN_RULE_ID];
                fa.setState(0);

                Integer[] input = inputStack.toArray(new Integer[] {});
                int lastMatchIndex = input.length;

                for (int i = input.length - 1; i >= 0 && fa.step(input[i]); i--) {
                    if (fa.isMatch()) {
                        lastMatchIndex = i;
                    }
                }

                for (int i = input.length - 1; i >= lastMatchIndex; i--) {
                    inputStack.pop();
                    stateStack.pop();
                }

                stateStack.push(this.gotoTable.get(stateStack.peek(),
                        action.ruleId()));
                inputStack.push(action.ruleId());
            } else if (action.type() == ActionType.Accept) {
                isMatch = true;
                break;
            } else {
                throw new IllegalStateException();
            }
        }

        return isMatch;
    }

    private class Action {
        private ActionType type;
        private int data;

        public Action(ActionType type, int data) {
            this.type = type;
            this.data = data;
        }

        public ActionType type() {
            return this.type;
        }

        public int ruleId() {
            return this.data;
        }

        public int state() {
            return this.data;
        }
    }

    private enum ActionType {
        Shift, Reduce, Accept, Error
    }

    private class Dfa {
        private CompressedMatrix<Integer> transitionTable;
        private int[] acceptStates;
        private int state;

        public Dfa(CompressedMatrix<Integer> transitionTable, int[] acceptStates) {
            this.transitionTable = transitionTable;
            this.acceptStates = acceptStates;
            this.state = 0;
        }

        public void setState(int state) {
            this.state = state;
        }

        public boolean isMatch() {
            int start = 0;
            int end = this.acceptStates.length;
            int mid = start + (end - start) / 2;

            while (start < end) {
                if (this.state < this.acceptStates[mid]) {
                    end = mid;
                    mid = start + (end - start) / 2;
                } else if (this.state > this.acceptStates[mid]) {
                    start = mid + 1;
                    mid = start + (end - start) / 2;
                } else {
                    break;
                }
            }

            return this.state == this.acceptStates[mid];
        }

        public boolean step(int character) {
            Integer newState = this.transitionTable.get(this.state, character);

            if (newState == null) {
                return false;
            }

            this.state = newState;
            return true;
        }
    }

    private class CompressedMatrix<T> {
        private T[] a;
        private int[] ia;
        private int[] ja;

        public CompressedMatrix(T[] a, int[] ia, int[] ja) {
            this.a = a;
            this.ia = ia;
            this.ja = ja;
        }

        public T get(int x, int y) {
            if (x >= this.ia.length - 1) {
                return null;
            }

            int start = this.ia[x];
            int end = this.ia[x + 1];
            int mid = start + (end - start) / 2;

            while (start < end) {
                if (y < this.ja[mid]) {
                    end = mid;
                    mid = start + (end - start) / 2;
                } else if (y > this.ja[mid]) {
                    start = mid + 1;
                    mid = start + (end - start) / 2;
                } else {
                    break;
                }
            }

            return y == this.ja[mid] ? this.a[mid] : null;
        }
    }
}
